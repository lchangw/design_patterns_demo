1.策略模式与简单工厂区别？
从实现方式上看，简单工厂是返回用户需要的实例，随后由用户操作；策略模式则是对具体策略实例的封装，用户直接操作封装后的策略实例
虽然如此分析，但什么时候用简单工厂、什么时候用策略模式、还是将二者融合使用，好像都可以实现目标啊？？？

2.单一职责原则 -- SRP
就一个类而言，应该仅有一个引起它变化的原因
软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离

3.开放封闭原则 -- OCP
不能修改，但可以扩展；通过构造抽象来隔离变化
开发人员应对频繁变化的部分做抽象，但每个部分都刻意的做抽象同样是不对的
一国两制、弹性工作制

4.依赖倒转原则 -- DIP
抽象不应依赖细节，细节应依赖抽象
面向接口编程，不要面向实现编程
高层不要依赖低层，二者都应依赖抽象

5.里是转换原则 -- LSP
子类型必须能够替代它们的父类型
子类拥有父类所有非private得属性和行为

6.迪米特法则 -- LoD
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用
在类的设计结构上，每一个类都应当尽量降低成员的访问权限，也就是说，一个类应包装好自己的private状态
强调了类之间的松耦合

7.合成/聚合原则
优先使用对象合成/聚合，尽量不要使用类继承
有助于保持每个类被封装，并被集中到单个 任务上
这样类和类继承层次会保持较小规模，不太可能增长为不可控制的庞然大物

8.模板方法与建造者模式区别？

9.父类无无参构造方法时，子类构造方法必须显式调用父类有参构造方法

10.子类能否覆盖父类成员变量的值？
不能覆盖，但可以继承，且可以在方法中修改

11.在方法中修改成员变量值是否有效？

12.敏捷开发原则
不要为代码添加基于猜测的、实际不需要的功能

13.抽象类为何不能实例化？